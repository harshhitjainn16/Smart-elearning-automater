{"ast":null,"code":"/**\r\n * API Service for Smart E-Learning Automator Frontend\r\n * Handles communication with the FastAPI backend\r\n */\n\nconst API_BASE_URL = 'http://localhost:8000';\nconst WS_URL = 'ws://localhost:8000/ws';\nclass ApiService {\n  constructor() {\n    this.websocket = null;\n    this.eventListeners = new Map();\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectDelay = 3000; // 3 seconds\n  }\n\n  /**\r\n   * Make HTTP request to API\r\n   */\n  async request(endpoint, options = {}) {\n    const url = `${API_BASE_URL}${endpoint}`;\n    const defaultOptions = {\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    };\n    try {\n      const response = await fetch(url, {\n        ...defaultOptions,\n        ...options\n      });\n      if (!response.ok) {\n        const error = await response.json().catch(() => ({\n          message: 'Unknown error'\n        }));\n        throw new Error(error.detail || error.message || `HTTP ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error(`API request failed for ${endpoint}:`, error);\n      throw error;\n    }\n  }\n\n  /**\r\n   * GET request\r\n   */\n  async get(endpoint) {\n    return this.request(endpoint, {\n      method: 'GET'\n    });\n  }\n\n  /**\r\n   * POST request\r\n   */\n  async post(endpoint, data = null) {\n    const options = {\n      method: 'POST'\n    };\n    if (data) {\n      options.body = JSON.stringify(data);\n    }\n    return this.request(endpoint, options);\n  }\n\n  /**\r\n   * Health check\r\n   */\n  async healthCheck() {\n    return this.get('/health');\n  }\n\n  /**\r\n   * Get automation status\r\n   */\n  async getStatus() {\n    return this.get('/status');\n  }\n\n  /**\r\n   * Start automation\r\n   */\n  async startAutomation(config) {\n    return this.post('/automation/start', config);\n  }\n\n  /**\r\n   * Stop automation\r\n   */\n  async stopAutomation() {\n    return this.post('/automation/stop');\n  }\n\n  /**\r\n   * Simulate quiz solving\r\n   */\n  async simulateQuiz() {\n    return this.post('/quiz/simulate');\n  }\n\n  /**\r\n   * Get statistics\r\n   */\n  async getStats() {\n    return this.get('/stats');\n  }\n\n  /**\r\n   * WebSocket connection management\r\n   */\n  connectWebSocket() {\n    var _this$websocket;\n    if (((_this$websocket = this.websocket) === null || _this$websocket === void 0 ? void 0 : _this$websocket.readyState) === WebSocket.OPEN) {\n      return;\n    }\n    try {\n      this.websocket = new WebSocket(WS_URL);\n      this.websocket.onopen = () => {\n        console.log('WebSocket connected');\n        this.reconnectAttempts = 0;\n        this.emit('connected', true);\n      };\n      this.websocket.onmessage = event => {\n        try {\n          const message = JSON.parse(event.data);\n          this.handleWebSocketMessage(message);\n        } catch (error) {\n          console.error('Failed to parse WebSocket message:', error);\n        }\n      };\n      this.websocket.onclose = () => {\n        console.log('WebSocket disconnected');\n        this.emit('connected', false);\n        this.attemptReconnect();\n      };\n      this.websocket.onerror = error => {\n        console.error('WebSocket error:', error);\n        this.emit('error', error);\n      };\n    } catch (error) {\n      console.error('Failed to connect WebSocket:', error);\n      this.attemptReconnect();\n    }\n  }\n\n  /**\r\n   * Handle incoming WebSocket messages\r\n   */\n  handleWebSocketMessage(message) {\n    const {\n      type,\n      data\n    } = message;\n    switch (type) {\n      case 'connection_established':\n        this.emit('statusUpdate', data);\n        break;\n      case 'progress_update':\n        this.emit('progressUpdate', data);\n        break;\n      case 'video_completed':\n        this.emit('videoCompleted', data);\n        break;\n      case 'quiz_completed':\n        this.emit('quizCompleted', data);\n        break;\n      case 'automation_started':\n        this.emit('automationStarted', data);\n        break;\n      case 'automation_stopped':\n        this.emit('automationStopped', data);\n        break;\n      case 'automation_completed':\n        this.emit('automationCompleted', data);\n        break;\n      case 'automation_error':\n        this.emit('automationError', data);\n        break;\n      case 'pong':\n        // Handle ping/pong for connection health\n        break;\n      default:\n        console.log('Unknown WebSocket message type:', type, data);\n    }\n  }\n\n  /**\r\n   * Attempt to reconnect WebSocket\r\n   */\n  attemptReconnect() {\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      this.reconnectAttempts++;\n      console.log(`Attempting WebSocket reconnect ${this.reconnectAttempts}/${this.maxReconnectAttempts}`);\n      setTimeout(() => {\n        this.connectWebSocket();\n      }, this.reconnectDelay);\n    } else {\n      console.error('Max WebSocket reconnect attempts reached');\n      this.emit('reconnectFailed', true);\n    }\n  }\n\n  /**\r\n   * Send ping to keep connection alive\r\n   */\n  sendPing() {\n    var _this$websocket2;\n    if (((_this$websocket2 = this.websocket) === null || _this$websocket2 === void 0 ? void 0 : _this$websocket2.readyState) === WebSocket.OPEN) {\n      this.websocket.send(JSON.stringify({\n        type: 'ping'\n      }));\n    }\n  }\n\n  /**\r\n   * Close WebSocket connection\r\n   */\n  disconnectWebSocket() {\n    if (this.websocket) {\n      this.websocket.close();\n      this.websocket = null;\n    }\n  }\n\n  /**\r\n   * Event listener management\r\n   */\n  on(event, callback) {\n    if (!this.eventListeners.has(event)) {\n      this.eventListeners.set(event, new Set());\n    }\n    this.eventListeners.get(event).add(callback);\n  }\n  off(event, callback) {\n    if (this.eventListeners.has(event)) {\n      this.eventListeners.get(event).delete(callback);\n    }\n  }\n  emit(event, data) {\n    if (this.eventListeners.has(event)) {\n      this.eventListeners.get(event).forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          console.error(`Error in event listener for ${event}:`, error);\n        }\n      });\n    }\n  }\n\n  /**\r\n   * Cleanup\r\n   */\n  cleanup() {\n    this.disconnectWebSocket();\n    this.eventListeners.clear();\n  }\n}\n\n// Create singleton instance\nconst apiService = new ApiService();\n\n// Auto-connect WebSocket when service is imported\nif (typeof window !== 'undefined') {\n  apiService.connectWebSocket();\n\n  // Send ping every 30 seconds to keep connection alive\n  setInterval(() => {\n    apiService.sendPing();\n  }, 30000);\n\n  // Cleanup on page unload\n  window.addEventListener('beforeunload', () => {\n    apiService.cleanup();\n  });\n}\nexport default apiService;","map":{"version":3,"names":["API_BASE_URL","WS_URL","ApiService","constructor","websocket","eventListeners","Map","reconnectAttempts","maxReconnectAttempts","reconnectDelay","request","endpoint","options","url","defaultOptions","headers","response","fetch","ok","error","json","catch","message","Error","detail","status","console","get","method","post","data","body","JSON","stringify","healthCheck","getStatus","startAutomation","config","stopAutomation","simulateQuiz","getStats","connectWebSocket","_this$websocket","readyState","WebSocket","OPEN","onopen","log","emit","onmessage","event","parse","handleWebSocketMessage","onclose","attemptReconnect","onerror","type","setTimeout","sendPing","_this$websocket2","send","disconnectWebSocket","close","on","callback","has","set","Set","add","off","delete","forEach","cleanup","clear","apiService","window","setInterval","addEventListener"],"sources":["D:/Harshit/Harshit C++/smart-elearning-automater/frontend/src/services/apiService.js"],"sourcesContent":["/**\r\n * API Service for Smart E-Learning Automator Frontend\r\n * Handles communication with the FastAPI backend\r\n */\r\n\r\nconst API_BASE_URL = 'http://localhost:8000';\r\nconst WS_URL = 'ws://localhost:8000/ws';\r\n\r\nclass ApiService {\r\n  constructor() {\r\n    this.websocket = null;\r\n    this.eventListeners = new Map();\r\n    this.reconnectAttempts = 0;\r\n    this.maxReconnectAttempts = 5;\r\n    this.reconnectDelay = 3000; // 3 seconds\r\n  }\r\n\r\n  /**\r\n   * Make HTTP request to API\r\n   */\r\n  async request(endpoint, options = {}) {\r\n    const url = `${API_BASE_URL}${endpoint}`;\r\n    const defaultOptions = {\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n      },\r\n    };\r\n\r\n    try {\r\n      const response = await fetch(url, { ...defaultOptions, ...options });\r\n      \r\n      if (!response.ok) {\r\n        const error = await response.json().catch(() => ({ message: 'Unknown error' }));\r\n        throw new Error(error.detail || error.message || `HTTP ${response.status}`);\r\n      }\r\n\r\n      return await response.json();\r\n    } catch (error) {\r\n      console.error(`API request failed for ${endpoint}:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * GET request\r\n   */\r\n  async get(endpoint) {\r\n    return this.request(endpoint, { method: 'GET' });\r\n  }\r\n\r\n  /**\r\n   * POST request\r\n   */\r\n  async post(endpoint, data = null) {\r\n    const options = {\r\n      method: 'POST',\r\n    };\r\n    \r\n    if (data) {\r\n      options.body = JSON.stringify(data);\r\n    }\r\n    \r\n    return this.request(endpoint, options);\r\n  }\r\n\r\n  /**\r\n   * Health check\r\n   */\r\n  async healthCheck() {\r\n    return this.get('/health');\r\n  }\r\n\r\n  /**\r\n   * Get automation status\r\n   */\r\n  async getStatus() {\r\n    return this.get('/status');\r\n  }\r\n\r\n  /**\r\n   * Start automation\r\n   */\r\n  async startAutomation(config) {\r\n    return this.post('/automation/start', config);\r\n  }\r\n\r\n  /**\r\n   * Stop automation\r\n   */\r\n  async stopAutomation() {\r\n    return this.post('/automation/stop');\r\n  }\r\n\r\n  /**\r\n   * Simulate quiz solving\r\n   */\r\n  async simulateQuiz() {\r\n    return this.post('/quiz/simulate');\r\n  }\r\n\r\n  /**\r\n   * Get statistics\r\n   */\r\n  async getStats() {\r\n    return this.get('/stats');\r\n  }\r\n\r\n  /**\r\n   * WebSocket connection management\r\n   */\r\n  connectWebSocket() {\r\n    if (this.websocket?.readyState === WebSocket.OPEN) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      this.websocket = new WebSocket(WS_URL);\r\n      \r\n      this.websocket.onopen = () => {\r\n        console.log('WebSocket connected');\r\n        this.reconnectAttempts = 0;\r\n        this.emit('connected', true);\r\n      };\r\n\r\n      this.websocket.onmessage = (event) => {\r\n        try {\r\n          const message = JSON.parse(event.data);\r\n          this.handleWebSocketMessage(message);\r\n        } catch (error) {\r\n          console.error('Failed to parse WebSocket message:', error);\r\n        }\r\n      };\r\n\r\n      this.websocket.onclose = () => {\r\n        console.log('WebSocket disconnected');\r\n        this.emit('connected', false);\r\n        this.attemptReconnect();\r\n      };\r\n\r\n      this.websocket.onerror = (error) => {\r\n        console.error('WebSocket error:', error);\r\n        this.emit('error', error);\r\n      };\r\n\r\n    } catch (error) {\r\n      console.error('Failed to connect WebSocket:', error);\r\n      this.attemptReconnect();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle incoming WebSocket messages\r\n   */\r\n  handleWebSocketMessage(message) {\r\n    const { type, data } = message;\r\n    \r\n    switch (type) {\r\n      case 'connection_established':\r\n        this.emit('statusUpdate', data);\r\n        break;\r\n      case 'progress_update':\r\n        this.emit('progressUpdate', data);\r\n        break;\r\n      case 'video_completed':\r\n        this.emit('videoCompleted', data);\r\n        break;\r\n      case 'quiz_completed':\r\n        this.emit('quizCompleted', data);\r\n        break;\r\n      case 'automation_started':\r\n        this.emit('automationStarted', data);\r\n        break;\r\n      case 'automation_stopped':\r\n        this.emit('automationStopped', data);\r\n        break;\r\n      case 'automation_completed':\r\n        this.emit('automationCompleted', data);\r\n        break;\r\n      case 'automation_error':\r\n        this.emit('automationError', data);\r\n        break;\r\n      case 'pong':\r\n        // Handle ping/pong for connection health\r\n        break;\r\n      default:\r\n        console.log('Unknown WebSocket message type:', type, data);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Attempt to reconnect WebSocket\r\n   */\r\n  attemptReconnect() {\r\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\r\n      this.reconnectAttempts++;\r\n      console.log(`Attempting WebSocket reconnect ${this.reconnectAttempts}/${this.maxReconnectAttempts}`);\r\n      \r\n      setTimeout(() => {\r\n        this.connectWebSocket();\r\n      }, this.reconnectDelay);\r\n    } else {\r\n      console.error('Max WebSocket reconnect attempts reached');\r\n      this.emit('reconnectFailed', true);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Send ping to keep connection alive\r\n   */\r\n  sendPing() {\r\n    if (this.websocket?.readyState === WebSocket.OPEN) {\r\n      this.websocket.send(JSON.stringify({ type: 'ping' }));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Close WebSocket connection\r\n   */\r\n  disconnectWebSocket() {\r\n    if (this.websocket) {\r\n      this.websocket.close();\r\n      this.websocket = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Event listener management\r\n   */\r\n  on(event, callback) {\r\n    if (!this.eventListeners.has(event)) {\r\n      this.eventListeners.set(event, new Set());\r\n    }\r\n    this.eventListeners.get(event).add(callback);\r\n  }\r\n\r\n  off(event, callback) {\r\n    if (this.eventListeners.has(event)) {\r\n      this.eventListeners.get(event).delete(callback);\r\n    }\r\n  }\r\n\r\n  emit(event, data) {\r\n    if (this.eventListeners.has(event)) {\r\n      this.eventListeners.get(event).forEach(callback => {\r\n        try {\r\n          callback(data);\r\n        } catch (error) {\r\n          console.error(`Error in event listener for ${event}:`, error);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cleanup\r\n   */\r\n  cleanup() {\r\n    this.disconnectWebSocket();\r\n    this.eventListeners.clear();\r\n  }\r\n}\r\n\r\n// Create singleton instance\r\nconst apiService = new ApiService();\r\n\r\n// Auto-connect WebSocket when service is imported\r\nif (typeof window !== 'undefined') {\r\n  apiService.connectWebSocket();\r\n  \r\n  // Send ping every 30 seconds to keep connection alive\r\n  setInterval(() => {\r\n    apiService.sendPing();\r\n  }, 30000);\r\n  \r\n  // Cleanup on page unload\r\n  window.addEventListener('beforeunload', () => {\r\n    apiService.cleanup();\r\n  });\r\n}\r\n\r\nexport default apiService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}